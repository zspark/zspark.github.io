author: Nancy
created: 20200102070827756
creator: Nancy
modified: 20200104093835712
modifier: Nancy
tags: essay C++
title: C++面试遇到的问题
type: text/vnd.tiddlywiki

!! 一、结构体求大小问题
```cpp
struct A1
{
    int a:4;
    int b:2;
    char c:1;
};
```
请问在32位系统中A1的内存大小。（类似的问题，我写的这个结构体内存大小应该为8）

!!!相关的问题：

!!!1）结构中的位字段

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与C语言一样，C++也允许指定占用特定位数的结构成员，这使得创建与某个硬件设备上的寄存器对应的数据结构非常方便。例如在存放一个开关量时，只有0和1两种状态，用一位二进位即可。字段的类型应为整型或枚举，接下来是冒号,冒号后面是一个数字，它指定了使用的位数。可以试用没有名称的字段来提供间距。每个成员都被称为位字段（bit field）。下面是一个例子：

```cpp
  struct   torgle_register
  {   
     unsigned int SN : 4;  // 4 bits for SN value
     unsigned int : 4;       // 4 bits for unused
     bool goolIn : 1;        // valid input (1 bit)
  };
```
    初始化、访问字段都和通常一样。


!!!2)结构体内存对齐：

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;元素是按照定义顺序一个一个放到内存中去的，但并不是紧密排列的。从结构体存储的首地址开始，每个元素放置到内存中时，它都会认为内存是按照自己的大小来划分的，因此元素放置的位置一定会在自己宽度的整数倍上开始。 内存对齐主要是提高处理器访问内存的速度。

```cpp
struct stu1
{
　int i;
　char c;
　int j;
}；
```
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先介绍一个相关的概念——偏移量。''偏移量''指的是 ''结构体变量中成员的地址'' 和 ''结构体变量地址'' 的差。''结构体大小''等于 ''最后一个成员的偏移量'' 加上 ''最后一个成员的大小''。显然，结构体变量中第一个成员的地址就是结构体变量的首地址。因此，第一个成员i的偏移量为0。第二个成员c的偏移量是第一个成员的偏移量加上第一个成员的大小（0+4）,其值为4；第三个成员j的偏移量是第二个成员的偏移量加上第二个成员的大小（4+1）,其值为5。


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，由于存储变量时地址对齐的要求，编译器在编译程序时会遵循两条原则：

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一、结构体变量中成员的偏移量必须是成员大小的整数倍（0被认为是任何数的整数倍） 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二、结构体大小必须是所有成员大小的整数倍


!!!对齐参数：

64位系统，默认对齐数为8; 

32位系统，默认对齐数为4;

设置对齐参数可在结构体struct之前加上#pragma pack(对齐数)，在struct之后加上#pragma pack;便可以设置对齐参数。 
对齐参数不能任意设置，只能是内置类型已有的字节数，如：char(1)、short（2），int（4），double(8)…不能是3，5…任意数。

!!!相关例题
下面的结构体大小分别是多大（假设32位机器）？

```cpp
struct A {
char a;
char b;
char c;
};

struct B {
int a;
char b;
short c;
};

struct C {
char b;
int a;
short c;
};
pragma pack(2)

struct D {
char b;
int a;
short c;
};
```

结构体的大小问题在求解的时候要注意对齐：

*A：对齐值为：1 。大小为：3
*B：对齐值为：4 。 大小为：4+2+2 = 8（第一个4为int，第二个4为char 和 short ，要空余1个）
*C：对齐值为：4。大小为：4+4+4 = 12（第一个为char ，空余3个，第二个为int ，第三个为char 空余3个）
*D：指定对齐值为：2（使用了#pragma pack(2)） 。大小为2+4+2 = 8。（第一个char，空余1个，第二个为int ，4个，第3个位char，空余1个）。

!! 二、按位运算符
题目：count的值为多少

```cpp
void solution(){
        int count = 0;
	int x = 9999;
	while(x){
		count++;
		x = x&(x-1);
	}
}
```
答案为8，需要将9999转换为2进制，并算出其中1的个数再+1 。

!!!相关知识：
!!!移位运算符
*左移运算符  value << shift  向左移动一位相当于乘以2，向右移动n位相当于乘以2^^n^^.
*右移运算符  value >> shift  向右移动一位相当于除以2，向右移动n位相当于除以2^^n^^.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value是要移动的整数值，shift是要移动的位数。腾出的位用0填充，超过边界的位被删除。
注意右移时对于有符号整数，腾出的位置可能用0填充，也可能用原来最左边的$$\KaTeX$$
位填充，这取决于C++的实现。


!!!逻辑按位运算符
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与常规逻辑运算符不同的是，它们用于值的每一位，而不是整个值。要先将其转换为2进制，再逐位运算。

 *位非（或求反）运算符（~）
<<<
        unsigned char x = 3;

        ~x :  将其写为2进制：00000011 再按位取反 得到值 11111100
<<<
   


*OR(|): 
<<<
1|0 = 1; 

0|0 = 0; 

1|1=1;
<<<
*XOR(^):  
<<<
1^0 = 0; 

0^0=1; 

1^1=1;
<<<
*AND(&):  
<<<
1&0 = 0; 

0&0=0; 

1&1=1;
<<<
*按位运算符的替代表示
|!标准表示|!替代表示|
| & |bitand|
| &= |and_eq|
| &#124; |bitor|
| &#124;= |or_eq|
| ~ |compl|
| ^ |xor|
| ^= |xor_eq|
使用方法：

```cpp
b = compl a bitand b;   //same as b = ~a & b;
c = a xor b;            //same as c = a ^ c; 
```
C++primer plus 第六版p856 讲了几种常用的按位运算符技术，需要时可参阅。
        

!!三、两个栈拼成一个队列
思路：入队时，直接压如stack1，出队时，判断stack2是否为空，如果为空，将stack1的元素全部压如stack2，再将stack2栈顶元素弹出，否则直接弹出stack2栈顶元素。代码实现如下：

```cpp
#include <iostream>
#include <stack>
using namespace std;

/*
*两个栈实现一个队列
*入队时，直接压入stack1中
*出队时，判断stack2是否为空，
*如果stack2为空，则将stack1中的元素倒入stack2中
*否则直接弹出stack2中的元素
*/
//入队
void EnQueue(stack<int> &s1,stack<int> &s2,int m)
{
	s1.push(m);
}
//出队
void DeQueue(stack<int> &s1,stack<int> &s2,int &m)
{
	if(s2.empty())
	{
		int p = s1.size();
		for(int i = 0; i < p; i++)
		{
			s2.push(s1.top());
			s1.pop();
		}
	}
	m = s2.top();
	s2.pop();
}

int main()
{
	stack<int> s1,s2;
	int m;
	for(int i = 0; i < 5; i++)
	{
		cin>>m;
		EnQueue(s1,s2,m);
		if(i>2)
		{
			DeQueue(s1,s2,m);
			cout<<"DeQueue element is "<<m<<endl;
		}
	}

	DeQueue(s1,s2,m);
	cout<<"DeQueue element is "<<m<<endl;
	return 0;
}
```

思考：两个队列拼成一个栈

```cpp
/*
*两个队列实现一个栈
*将queue1用作进栈出栈，queue2作为一个中转站
*入栈时，直接压入queue1中
*出栈时，先将queue1中的元素除最后一个元素外依次出队列，
*并压入队列queue2中
*将留在queue1中的最后一个元素出队列即为出栈元素
*最后还要把queue2中的元素再次压入queue1中
*/

#include <iostream>
#include <queue>
using namespace std;

//进栈操作
void stackpush(queue<int> &q1,queue<int> &q2,int m)
{
	q1.push(m);
}

//出栈操作
void stackpop(queue<int> &q1,queue<int> &q2,int &m)
{
	int p = q1.size();
	for(int i = 0;i < p-1; i++)
	{
		q2.push(q1.front());
		q1.pop();
	}
	m = q1.front();
	q1.pop();
	int l = q2.size();
	for(int j = 0; j < l; j++)
	{
		q1.push(q2.front());
		q2.pop();
	}
}

int main()
{
	queue<int> q1,q2;
	int n;
	for(int i = 0; i < 6; i++)
	{
		cin>>n;
		stackpush(q1,q2,n);
		if(i>3)
		{
			stackpop(q1,q2,n);
			cout<<"stackpop element is "<<n<<endl;
		}
	}

	stackpop(q1,q2,n);
	cout<<"stackpop element is "<<n<<endl;
	return 0;
}
```

!!四、字符串问题
strlen与sizeof的区别：strlen不算‘\0’