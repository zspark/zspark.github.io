author: Nancy
created: 20200102070827756
creator: Nancy
modified: 20200110102637566
modifier: Nancy
tags: essay C++
title: C++面试遇到的问题
type: text/vnd.tiddlywiki

!! 一、结构体求大小问题
```cpp
struct A1
{
    int a:4;
    int b:2;
    char c:1;
};
```
请问在32位系统中A1的内存大小。（类似的问题，我写的这个结构体内存大小应该为8）

!!!相关的问题：

!!!1）结构中的位字段

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与C语言一样，C++也允许指定占用特定位数的结构成员，这使得创建与某个硬件设备上的寄存器对应的数据结构非常方便。例如在存放一个开关量时，只有0和1两种状态，用一位二进位即可。字段的类型应为整型或枚举，接下来是冒号,冒号后面是一个数字，它指定了使用的位数。可以试用没有名称的字段来提供间距。每个成员都被称为位字段（bit field）。下面是一个例子：

```cpp
  struct   torgle_register
  {   
     unsigned int SN : 4;  // 4 bits for SN value
     unsigned int : 4;       // 4 bits for unused
     bool goolIn : 1;        // valid input (1 bit)
  };
```
    初始化、访问字段都和通常一样。


!!!2)结构体内存对齐：

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;元素是按照定义顺序一个一个放到内存中去的，但并不是紧密排列的。从结构体存储的首地址开始，每个元素放置到内存中时，它都会认为内存是按照自己的大小来划分的，因此元素放置的位置一定会在自己宽度的整数倍上开始。 内存对齐主要是提高处理器访问内存的速度。

```cpp
struct stu1
{
　int i;
　char c;
　int j;
}；
```
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先介绍一个相关的概念——偏移量。''偏移量''指的是 ''结构体变量中成员的地址'' 和 ''结构体变量地址'' 的差。''结构体大小''等于 ''最后一个成员的偏移量'' 加上 ''最后一个成员的大小''。显然，结构体变量中第一个成员的地址就是结构体变量的首地址。因此，第一个成员i的偏移量为0。第二个成员c的偏移量是第一个成员的偏移量加上第一个成员的大小（0+4）,其值为4；第三个成员j的偏移量是第二个成员的偏移量加上第二个成员的大小（4+1）,其值为5。


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，由于存储变量时地址对齐的要求，编译器在编译程序时会遵循两条原则：

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一、结构体变量中成员的偏移量必须是成员大小的整数倍（0被认为是任何数的整数倍） 

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二、结构体大小必须是所有成员大小的整数倍


!!!对齐参数：

64位系统，默认对齐数为8; 

32位系统，默认对齐数为4;

设置对齐参数可在结构体struct之前加上#pragma pack(对齐数)，在struct之后加上#pragma pack;便可以设置对齐参数。 
对齐参数不能任意设置，只能是内置类型已有的字节数，如：char(1)、short（2），int（4），double(8)…不能是3，5…任意数。

!!!相关例题
下面的结构体大小分别是多大（假设32位机器）？

```cpp
struct A {
char a;
char b;
char c;
};

struct B {
int a;
char b;
short c;
};

struct C {
char b;
int a;
short c;
};
pragma pack(2)

struct D {
char b;
int a;
short c;
};
```

结构体的大小问题在求解的时候要注意对齐：

*A：对齐值为：1 。大小为：3
*B：对齐值为：4 。 大小为：4+2+2 = 8（第一个4为int，第二个4为char 和 short ，要空余1个）
*C：对齐值为：4。大小为：4+4+4 = 12（第一个为char ，空余3个，第二个为int ，第三个为char 空余3个）
*D：指定对齐值为：2（使用了#pragma pack(2)） 。大小为2+4+2 = 8。（第一个char，空余1个，第二个为int ，4个，第3个位char，空余1个）。

!! 二、按位运算符
题目：count的值为多少

```cpp
void solution(){
        int count = 0;
	int x = 9999;
	while(x){
		count++;
		x = x&(x-1);
	}
}
```
答案为8，需要将9999转换为2进制，并算出其中1的个数再+1 。

!!!相关知识：
!!!移位运算符
*左移运算符  value << shift  向左移动一位相当于乘以2，向右移动n位相当于乘以2^^n^^.
*右移运算符  value >> shift  向右移动一位相当于除以2，向右移动n位相当于除以2^^n^^.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value是要移动的整数值，shift是要移动的位数。腾出的位用0填充，超过边界的位被删除。
注意右移时对于有符号整数，腾出的位置可能用0填充，也可能用原来最左边的$$\KaTeX$$
位填充，这取决于C++的实现。


!!!逻辑按位运算符
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与常规逻辑运算符不同的是，它们用于值的每一位，而不是整个值。要先将其转换为2进制，再逐位运算。

 *位非（或求反）运算符（~）
<<<
        unsigned char x = 3;

        ~x :  将其写为2进制：00000011 再按位取反 得到值 11111100
<<<
   


*OR(|): 
<<<
1|0 = 1; 

0|0 = 0; 

1|1=1;
<<<
*XOR(^):  
<<<
1^0 = 0; 

0^0=1; 

1^1=1;
<<<
*AND(&):  
<<<
1&0 = 0; 

0&0=0; 

1&1=1;
<<<
*按位运算符的替代表示
|!标准表示|!替代表示|
| & |bitand|
| &= |and_eq|
| &#124; |bitor|
| &#124;= |or_eq|
| ~ |compl|
| ^ |xor|
| ^= |xor_eq|
使用方法：

```cpp
b = compl a bitand b;   //same as b = ~a & b;
c = a xor b;            //same as c = a ^ c; 
```
C++primer plus 第六版p856 讲了几种常用的按位运算符技术，需要时可参阅。
        

!!三、两个栈拼成一个队列
思路：入队时，直接压如stack1，出队时，判断stack2是否为空，如果为空，将stack1的元素全部压如stack2，再将stack2栈顶元素弹出，否则直接弹出stack2栈顶元素。代码实现如下：

```cpp
#include <iostream>
#include <stack>
using namespace std;

/*
*两个栈实现一个队列
*入队时，直接压入stack1中
*出队时，判断stack2是否为空，
*如果stack2为空，则将stack1中的元素倒入stack2中
*否则直接弹出stack2中的元素
*/
//入队
void EnQueue(stack<int> &s1,stack<int> &s2,int m)
{
	s1.push(m);
}
//出队
void DeQueue(stack<int> &s1,stack<int> &s2,int &m)
{
	if(s2.empty())
	{
		int p = s1.size();
		for(int i = 0; i < p; i++)
		{
			s2.push(s1.top());
			s1.pop();
		}
	}
	m = s2.top();
	s2.pop();
}

int main()
{
	stack<int> s1,s2;
	int m;
	for(int i = 0; i < 5; i++)
	{
		cin>>m;
		EnQueue(s1,s2,m);
		if(i>2)
		{
			DeQueue(s1,s2,m);
			cout<<"DeQueue element is "<<m<<endl;
		}
	}

	DeQueue(s1,s2,m);
	cout<<"DeQueue element is "<<m<<endl;
	return 0;
}
```

思考：两个队列拼成一个栈

```cpp
/*
*两个队列实现一个栈
*将queue1用作进栈出栈，queue2作为一个中转站
*入栈时，直接压入queue1中
*出栈时，先将queue1中的元素除最后一个元素外依次出队列，
*并压入队列queue2中
*将留在queue1中的最后一个元素出队列即为出栈元素
*最后还要把queue2中的元素再次压入queue1中
*/

#include <iostream>
#include <queue>
using namespace std;

//进栈操作
void stackpush(queue<int> &q1,queue<int> &q2,int m)
{
	q1.push(m);
}

//出栈操作
void stackpop(queue<int> &q1,queue<int> &q2,int &m)
{
	int p = q1.size();
	for(int i = 0;i < p-1; i++)
	{
		q2.push(q1.front());
		q1.pop();
	}
	m = q1.front();
	q1.pop();
	int l = q2.size();
	for(int j = 0; j < l; j++)
	{
		q1.push(q2.front());
		q2.pop();
	}
}

int main()
{
	queue<int> q1,q2;
	int n;
	for(int i = 0; i < 6; i++)
	{
		cin>>n;
		stackpush(q1,q2,n);
		if(i>3)
		{
			stackpop(q1,q2,n);
			cout<<"stackpop element is "<<n<<endl;
		}
	}

	stackpop(q1,q2,n);
	cout<<"stackpop element is "<<n<<endl;
	return 0;
}
```

!!四、字符串问题

*strlen与sizeof的区别：

<<<
sizeof运算指出整个数组的长度，单strlen()函数返回的是存储在数组中的字符串长度，且不把空字符‘\0’计算在内。
<<<

*字符串输入：
1.用字符数组输入

<<<
cin使用空白（空格、制表符和换行符）来确定字符串的结束位置。故cin在获取字符数组输入时只读取一个单词，读取该单词后cin将该字符串放到数组中，并自动在结尾添加空字符。

每次读取一行字符串输入：istream中的类（如cin）提供了一些面向行的类成员函数：getline()和get()。

1.面向行的输入getling()

getline()函数读取整行，它使用通过回车输入的换行符来确定输入结尾，并在存储字符串时，用空字符来替换换行符。该函数有两个参数，第一个为用来存储输入行的数组的名称，第二个参数是要读取的字符数组，如输入20，则最多存储19个字符，余下的空间用于存储自动在结尾处添加的空字符。getline()成员函数在读取指定数目的字符和换行符时停止读取。例如：

```cpp
cin.getline(name,20);
```

2.面向行的输入get()

get()成员函数有几种变体，其中一种变体的工作方式与getline()类似，它们接受的参数相同，解释参数的方式也相同，并且都读取到行尾，但get并不再读取并丢弃换行符，而是将其留在输入队列中。故连续调用get的时候要注意换行符：

```cpp
cin.get(name,size);       //read first line
cin.get();                        //read new line
cin.get(name2,size);     //read second line

//第二种写法
cin.get(name,size).get();    //concatenate member functions
```





<<<
!!五、类和结构的区别

<<<
类和结构很像，C++对结构进行了拓展，使之具有与类相同的特性。它们之间唯一的区别是：

结构的默认访问类型是public ,而类为private。
<<<

!!六、类的构造函数和析构函数

<<<
初始化类的对象与常规的初始化语法不同，由于类的部分数据的访问状态是私有的，这意味着程序不能直接访问数据成员，只能通过成员函数来访问数据成员，因此需要设计合理的构造函数。

默认构造函数是在未提供显式初始值时，用来创建对象的构造函数。如果没有提供任何构造函数，C++将自动提供默认构造函数，它是默认构造函数的隐式版本。默认构造函数没有参数，因为声明中不包含值。

```cpp
student::student(){}
```

当且仅当没有定义任何构造函数时，编译器才会提供默认构造函数。为类定义了构造函数后，必须自己为它提供默认构造函数。
<<<

例如：

```cpp
#include <iostream>
using namespace std;
class student
{
  private:
    std::string m_sName;
    int m_nGrade;
    int m_nClass
  public:
      stock()
      {
        m_sName = "no name";
        m_nGrade = 0;
        m_nClass = 0;
      }    //默认构造函数一种写法
      //stock(string name = "no name", int grade = 0, int class = 0);   //另一种默认构造函数的写法，给已有构造函数的所有参数提供默认值
      stock(string name, int grade, int nClass)
      {
        m_sName = name;
        if(grade<0)
        {
          cerr<<"Number of m_nGrade can't be nagetive; "<<name<<" 's grade set to 0.\n";
          m_nGrade = 0;
        }
        else n_nGrade = grade;
        if(nClass<0)
        {
          cerr<<"Number of m_nClass can't be nagetive; "<<name<" 's Class set to 0.\n";
          m_nClass = 0;
        }
        else m_nClass = nClass;
      }       //自定构造函数
};

```

六、链表逆序

七、内存分配方法P117

八、一个棋盘，从左上角走到右下角有几条路径。

九、文件的读写