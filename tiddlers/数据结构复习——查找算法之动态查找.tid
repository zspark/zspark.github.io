author: Nancy
created: 20200104093936138
creator: Nancy
modified: 20200105152825065
modifier: Nancy
tags: essay
title: 数据结构复习——查找算法之动态查找
type: text/vnd.tiddlywiki

!!二、动态查找
*二叉排序树

```cpp
#include <iostream>
using namespace std;

//二叉树的二叉链表结点结构定义
typedef struct BiTNode
{
	int data;
	struct BiTNode *lchild, *rchild;
}BiTNode,*BiTree;


//递归查找二叉排序树 T 中是否存在key
//指针 f 指向 T 的双亲，其初始值调用值为NULL
//若茶中成功，则指针 p 指向该数据元素结点，并返回TRUE
//否则指针 p 指向查找路径上访问的最后一个结点，并返回FALSE
bool SearchBST(BiTree T, int key, BiTree f, BiTree *p)
{
	if(!T) //查找不成功
	{
		*p = f;
		return FALSE;
	}
	else if( key == T->data )  //查找成功
	{
		*p = T;
		return TRUE;
	}
	else if( key < T->data )
	{
		return SearchBST( T->lchild, key, T, p);  //在左子树查找
	}
	else
	{
		return SearchBST( T->lchild, key, T, p);  //在右子树继续查找
	}
}

//当二叉排序树 T 中不存在关键字等于 key 的数据元素时，
//插入 key 并返回TRUE，否则返回 FALSE
bool InsertBST(BiTree *T, int key)
{
	BiTree p, s;
	if( !SearchBST(*T, key, NULL, &p))
	{
		s = (BiTree)malloc(sizeof(BiTNode));
		s->data = key;
		s->lchild = s->rchild = NULL;

		if( !p ) //查不到 key
		{
			*T = s;   //插入s为新的根节点
		}
		else if( key < p->data )
		{
			p->lchild = s;  // 插入 s 为左孩子
		}
		else
		{
			p->rchild = s;  // 插入 s 为右孩子
		}
	}
	else
	{
		return FALSE;   // 树中已有关键字相同的结点，不再插入
	}
}

void InOrder(BiTree T)    //先序遍历
{
  if(T != NULL)
  {
    InOrder(T->lchild);
    cout<<" "<<T->data<<" ";
    InOrder(T->rchild);
  }
}

int main()
{
  BiTree T = new BiTNode();
  T->data = 3;
  T->lchild = T->rchild = NULL;

  for(int i = 0; i < 5; i++)
  {
    insertBST(&T,i);
  }
  cout<<T->data<<endl;
  InOrder(T);
  cout<<endl;
  return 0;
}

```

以上方法用到二级指针，比较复杂，jerry老师帮我简化了下

```cpp
#include <iostream>
using namespace std;

struct BiTree
{
    int data{-1};
    BiTree* lchild{nullptr};
    BiTree* rchild{nullptr};
};

/**
 * search the given BiTree t, and return a node which has the value of data.
 * if return nullptr ,means there is already a node which has the value of data in the tree.
 */

BiTree* SearchAndInsert(BiTree* t, int data)
{
    if(t == nullptr)
    {
        BiTree* _t = new BiTree();
        _t->data = data;
        return _t;
    }
    if(t->data > data)
    {
        Bitree* tmp = SearchAndInsert(t->lchild,data);
        if(tmp) t->lchild = tmp;
    }
    else if(t->data < data)
    {
        BiTree* tmp = SearchAndInsert(t->rchild,data);
        if(tmp) t->rchild = tmp;
    }
    return nullptr;
}

void Print(BiTree* t){
	if(t==nullptr)return;
	Print(t->lChild);
	cout<<t->data<<",";
	Print(t->rChild);
};

int main(int argc, char** argv){

	BiTree* tree=new BiTree();
	tree->data=50;

	for(int i=0;i<100;++i){
		BiTree* t=SearchAndInsert(tree,i);
	}

	Print(tree);

	return 0;
}


```