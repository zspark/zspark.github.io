created: 20200103093926454
creator: Nancy
modified: 20200104085558942
modifier: Nancy
tags: essay
title: 数据结构复习——查找算法之静态查找
type: text/vnd.tiddlywiki

!查找算法
查找算法性能分析：时间复杂度、空间复杂度、平均查找长度
对于含有n个记录的表，查找成功时的''平均查找长度''为：

<<<
ASL =  $$ \sum$$P,,i,,C,,i,, ,i=1,2,...n

其中：

P,,i,,为查找表中第i个记录的概率，且$$ \sum$$P,,i,, = 1 ,i=1,2,...n

C,,i,,为找到目标关键字时，和给定值已经比较过的关键字个数。
<<<

!!一、静态查找

*''顺序查找  时间复杂度为O(n) ''
```cpp
//a为待查找数组，n为查找数组的长度，key为查找的关键字
int sqSearch(int *a, int n, int key)
{
    int i = n;
    a[0] = key;
    while(a[i]!=key)
    {
        i--;
    }
    return i;
}
```

*''折半查找 时间复杂度为O( log,,2,,n )''

<<<
先确定待查记录所在范围，再逐步缩小范围直到找到或找不到该记录为止。
<<<

```cpp
#include<iostream>
using namespace std;
//迭代
int binSearch(int str[], int n, int key)
{
	int low,high,mid;
	low = 0;
	high = n-1;
	while( low <= high )
	{
		mid = (low + high)/2;
		if(str[mid] == key)
		{
			return mid;     //查找成功
		}
		if(str[mid] < key)
		{
			low = mid +1;   //在后半序列中查找
		}
		if(str[mid] > key)
		{
			high = mid -1;  //在前半序列查找
		}
	}
	return -1;              //查找失败
}

//递归
int refind(int *data,int begin,int end,int num)
{
	if(begin > end)
	{
		//cout<<"没找到"<<endl;
		return -1;
	}

	int mid = (begin+end)/2;

	if(data[mid] == num)
	{
		return mid;
	}
	else if(data[mid] <= num)
		return refind(data,mid+1,end,num);
	else
		return refind(data,begin,mid-1,num);
}

int main()
{
	int str[11] = {1,1,2,3,5,7,9,11,23,32,33};
	int n, addr;

	cout<<"请输入待查找关键字： ";
	cin>>n;

	//addr = binSearch(str,11,n);
	addr = refind(str,0,10,n);
	if(-1 != addr)
	{
		cout<<"查找成功，关键字 "<<n<<" 所在的位置是："<<addr<<endl;
	}
	else
	{
		cout<<"查找失败"<<endl;
	}
	return 0;
}

```
*''插值查找  时间复杂度为O( log,,2,,n )''

<<<
插值查找只适合关键字均匀分布的表
<<<

```cpp
int binSearch(int str[], int n, int key)
{
	int low,high,mid;
	low = 0;
	high = n-1;
	while( low <= high )
	{
		//mid = (low + high)/2;  //折半查找
		mid = low+float(1.0*(key-str[low])/(str[high]-str[low]))*(high-low);  //插值查找
		if(str[mid] == key)
		{
			return mid;     //查找成功
		}
		if(str[mid] < key)
		{
			low = mid +1;   //在后半序列中查找
		}
		if(str[mid] > key)
		{
			high = mid -1;  //在前半序列查找
		}
	}
	return -1;              //查找失败
}
```

*''斐波那契查找 时间复杂度为O( log,,2,,n )''
```cpp
// 斐波那契查找.cpp 

#include <memory>
#include  <iostream>
using namespace std;

const int max_size=20;//斐波那契数组的长度

/*构造一个斐波那契数组*/ 
void Fibonacci(int * F)
{
    F[0]=0;
    F[1]=1;
    for(int i=2;i<max_size;++i)
        F[i]=F[i-1]+F[i-2];
}

/*定义斐波那契查找法*/  
int FibonacciSearch(int *a, int n, int key)  //a为要查找的数组,n为要查找的数组长度,key为要查找的关键字
{
  int low=0;
  int high=n-1;
  
  int F[max_size];
  Fibonacci(F);//构造一个斐波那契数组F 

  int k=0;
  while(n>F[k]-1)//计算n位于斐波那契数列的位置
      ++k;

  int  * temp;//将数组a扩展到F[k]-1的长度
  temp=new int [F[k]-1];
  memcpy(temp,a,n*sizeof(int));

  for(int i=n;i<F[k]-1;++i)
     temp[i]=a[n-1];
  
  while(low<=high)
  {
    int mid=low+F[k-1]-1;
    if(key<temp[mid])
    {
      high=mid-1;
      k-=1;
    }
    else if(key>temp[mid])
    {
     low=mid+1;
     k-=2;
    }
    else
    {
       if(mid<n)
           return mid; //若相等则说明mid即为查找到的位置
       else
           return n-1; //若mid>=n则说明是扩展的数值,返回n-1
    }
  }  
  delete [] temp;
  return -1;
}

int main()
{
    int a[] = {0,16,24,35,47,59,62,73,88,99};
    int key=16;
    int index=FibonacciSearch(a,sizeof(a)/sizeof(int),key);
    cout<<key<<" is located at:"<<index;
    return 0;
}
```

*''分块查找''

<<<
又称索引顺序查找，是顺序查找的一种改进方法，尚需建立一个“索引表”。

每个索引项包括两个内容：1关键字项（其值为孩子表内的做大关键字），2指针项（指示该子表的第一个记录在表中的位置）。

索引表按关键字有序，则 表 有序或分块有序。

分块查找过程分两步：

#确定要查找的关键字可能存在的具体块（子表）；
#在具体的块中进行顺序查找。
<<<

