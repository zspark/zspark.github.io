created: 20190818123243619
creator: Jerry
modified: 20190907030358068
modifier: Jerry
tags: _icg_ [[computer science]] [[computer graphics]]
title: 3 几何对象和变换 (interactive computer graphics)
type: text/vnd.tiddlywiki

<<list-links "[tag[_icg_]sort[title]]">>

!三维图元

二维图元比较简单，比如点、线段、三角形等，但毕竟我们生活在三维空间中，不可避免要涉及到三维图元的思考。在三维图元中，会遇到至少两个问题：

*三维图元的数学定义可能会很复杂；
*三维对象非常多，我们只能对图形系统能有效实现的对象感兴趣，现有的图形系统不能支持所有的三维对象，除非通过近似的方法；

图形学发展至今，前辈们选择了使用网格的形式描述三维对象。这些三维对象具有以下特征：

* 可以通过其表面来描述外观，并且认为对象是中空的；
* 可以由三维空间中的一组定点来确定；
* 表面要么可以用二维空间中的平面凸多边形来组成，要么可以通过它们来近似；


!标架


我们在中学开始接触的解析几何就是在三维空间中进行的，其中三维空间是建立在坐标系中。想想那个时候的坐标系有什么东西吧：一个被称为原点的点，外加3个互相垂直的向量，向量虽然没有位置的概念，但这里的三个向量必须要以原点为起始点去建立。标架的描述性定义于此类同但不限于刚才的描述，具体而言就是去掉“相互垂直”与“三维”这两个约束，即：一个指定的点（被称为原点）外加空间中的一个基（基的构建要以原点为起点）。至于标架与坐标系有什么关系，我觉得坐标系范围更广比如还有极坐标系，球面坐标系等等而且坐标系这个概念更通俗，就是哪个学科都能说“来，我们先建立个坐标系。”，而标架的概念应该更加专业，更加与具体的科学相关。现在说一下格式中“原点”的含义，原点无非空间中的一个特殊的点，而点是离不开具体标架的，从这层含义来说当指定一个具体标架后，其中原点的定义是与该标架的基相关的，只不过各个分量为0。但千万不要与其他标架下的原点混淆，认为他们是同一个标架，更不要认为是同一个点，所以不同标架下原点之间的关系，依然是建立在具体标架下的。

!齐次表示

我们在中学就开始接触三维空间，比如当时的解析代数。三维空间中的一个点P，其表示方式就是$$(x,y,z)$$，三维空间中的一个没有位置概念的向量也是$(x,y,z)$，如果将这种没有明确区分点与向量表达式的方式用在计图里面，那将是一片混乱，最简单的来说我们就难以使用流水线形式处理几何对象((说到这里我觉得自己编程的思想与图形系统绘制管线颇为相似，我始终觉得一个管理类型的对象在控制对象的过程中不应该为特殊对象进行特殊处理，比如初始化一个控制渲染的对象，一旦初始化成功它就进入帧循环模式，就需要不停的渲染“当前对象”，而“当前对象”的创建是由用户动态指定的。此时可以采用两种方式，一种是在帧循环中写入if..else..，另一种是初始化成功就给“当前对象”创建没有实际效果的渲染对象实例。我编程从来偏向使用第二种方式，<del>始终觉得在这种情况下if..else..除了浪费性能外别无它用</del>，性能上不能一口否定，但逻辑的清晰度上后者明显优于前者。))。于是发展出来用四位齐次坐标的形式描述他们（至于为什么叫“齐次”，我始终没有自我感觉理解到位）。我们用$$(x,y,z,1)$$表示空间中一个点，用$(x,y,z,0)$表示空间中一个向量，其中0，1可不是随意安排，他们是来自数学定义。 我们知道任何一个向量空间都有无数个基，在指定一个具体的基后，其空间中的任何一个向量可以唯一的表示成$$v=aw_x+bw_y+cw_z$$写成矩阵形式就是： 

$$v=[a,b,c] \left[\begin{matrix} w_x\\w_y\\w_z \end{matrix} \right]$$ 

而一个仿射空间的点在给定标架下的表示是:

$$P=[a,b,c] \left[\begin{matrix} w_x\\w_y\\w_z \end{matrix} \right]+P_0$$


意思就是$$P_0$$是开始点，然后移动了一个向量后的表示；如果没有开始点，那么就是加上了标架的原点，写成这种方式更普遍一些。现在我们尝试将$$P_0$$写入矩阵，试图用一个矩阵表示完整个过程，无论如何在三维矩阵下是做不到的，只有扩展到四维矩阵下才可以，因为多出来的一个维度可以用来存储额外的信息。于是$$P$$点我们可以写成：

$$P=[a,b,c,1] \left[\begin{matrix} w_x\\w_y\\w_z\\P_0 \end{matrix} \right]$$

<<.warning 上式从数学的角度看没有问题，但是从仿射空间的定义来看有错误的地方，错误出在仿射空间没有定义标量与点的运算（参见这里），所以我们需要约定：$$1P=P$$ ，意思是标量1与任何一个点相乘还是这个点，（没有约定其它非零标量与点相乘的含义，例如不能刻意认为标量3乘以点P，是将点P放大3倍或者其他什么意思。>>

到目前我们至少明确区分了在计图中点与向量的表示：一个用三维矩阵三维向量，一个用四维矩阵四维向量。从数学上讲这是对的没有问题。但是要知道我们的管线是流水线形式的，任何数据试图用统一的方式进行处理，现在使用特别频繁的点与向量用两种维度的矩阵、向量表示岂不是有违流水线的意思。于是前辈们苦心经营，%red%约定了$$0P=0$$ ，意思是标量0与任何一个点相乘就是原点$(0,0,0)$%%，这样一来，只要给定标架，空间中任何一个向量可以表示为：

$$v=[a,b,c,0] \left[\begin{matrix} w_x\\w_y\\w_z\\P_0 \end{matrix} \right]$$

至此，我们才统一了在计图中点与向量的表示方式：点就是$$(x,y,z,1)$$，向量就是$$(x,y,z,0)$$，没准这也是为什么叫“齐次表示”的一个原因吧。

!标架变换


标架变换是个很重要的概念，涉及到的问题就是：空间中同一个点在不同的标架下分别是什么表示，怎么互相转换。我们先布置一个环境：有一个标架$$v\{v_1,v_2,v_3,v0\}$$，在$$v$$标架下有一个点$$P=(a,b,c,1)$$；有另一个标架$$u\{u_1,u_2,u_3,u0\}$$，它与$$v$$标架的关系如下：


$$ \begin{align} u_1 &=2v_1\\ u_2 &=v_1+v_2\\ u_3 &=v_1+v_2+3v_3\\ u0  &=v0+(2,2,2,0)\\ \end{align} $$


其中$(2,2,2,0)$是v标架下的一个方向，表示$v$下的原点需要移动自己标架下定义的$(2,2,2,0)$这个方向后就会与标架$u$在空间中指定的原点$u0$重合。好了，现在要求计算点$P$在$u$标架下的表示。我们先将标架$v$与$u$的关系写成矩阵的形式：

$$ \left[u_1,u_2,u_3,u0 \right]^T =\left[ \begin{matrix} 2&0&0&0\\ 1&1&0&0\\ 1&1&3&0\\ 2&2&2&1\\ \end{matrix} \right] \left[v_1,v_2,v_3,v0 \right]^T $$

然后假设点$P$在$u$标架下的表示为$(d,e,f,1)$，于是：

$$ P=(a,b,c,1)v=(d,e,f,1)u=(d,e,f,1)\left[ \begin{matrix} 2&0&0&0\\ 1&1&0&0\\ 1&1&3&0\\ 2&2&2&1\\ \end{matrix} \right]v $$

可以得到$(a,b,c,1)$与$(d,e,f,1)$之间的关系：

$$ (a,b,c,1)=(d,e,f,1) \left[ \begin{matrix} 2&0&0&0\\ 1&1&0&0\\ 1&1&3&0\\ 2&2&2&1\\ \end{matrix} \right] $$

把矩阵写左边就是：

$$ (a,b,c,1)^T= \left[ \begin{matrix} 2&1&1&2\\ 0&1&1&2\\ 0&0&1&2\\ 0&0&0&1\\ \end{matrix} \right] (d,e,f,1)^T= \left[ \begin{matrix} 2&0&0&0\\ 1&1&0&0\\ 1&1&3&0\\ 2&2&2&1\\ \end{matrix} \right]^T (d,e,f,1)^T=M(d,e,f,1)^T $$

上面等式就说明了同一个空间下两个不同的标架之间的变换关系，从等式中可以看到u标架下的任何一个点的坐标右乘矩阵$M$就可以得到该点在$v$空间下的坐标；

!平移、缩放、旋转、切变


空间中最基本的变换莫过于上面这四种了。平移与缩放非常简单，这里主要说下旋转与切变。


!!旋转

[{{ :computer-graphics:interactive-computer-graphics:cg3:image_cg3_0.jpg?direct&200|A点围绕x轴旋转到A'点}}]

旋转相对复杂，我们先针对物体仅仅围绕$x$轴的旋转来说明，想象空间中一个点，围绕其标架下的$x$轴旋转，此时只有该点的$x$轴上的分量不变化，而$y$、$z$轴上的分量都会发生变化。当点$A(a,b)$围绕$x$轴旋转了$\beta$角度之后到$A'(c,d)$位置，两点的坐标关系如下（其中$L$表示点与原点的距离）:

$$a=Lcos\alpha \\ b=Lsin\alpha \\ c=Lcos(\alpha+\beta)=Lcos\alpha cos\beta-Lsin\alpha sin\beta =acos\beta -bsin\beta \\ d=Lsin(\alpha+\beta)=Lsin\alpha cos\beta +Lsin\alpha cos\beta =bsin\beta +acos\beta $$

写成矩阵形式就是：

$$ A'=\left[ \begin{matrix} cos\beta&-sin\beta\\ sin\beta&cos\beta\\ \end{matrix} \right]A $$

写成四维齐次坐标的形式就是：

$$ M=\left[ \begin{matrix} 1&0&0&0\\ 0&cos\beta&-sin\beta&0\\ 0&sin\beta&cos\beta&0\\ 0&0&0&1 \end{matrix} \right] $$

空间中物体围绕其标架的y轴、z轴旋转的情况如此类同，一样的推导就能得出。


!!错切（切变）


[{{ :computer-graphics:interactive-computer-graphics:cg3:image_cg3_2.jpg?direct&200|物体的错切变换}}]

错切变换好比对象自身将自己一层一层偏离了原来的地方，如图所示。原来的物体是淡绿色方形，经过错切变换后成了淡粉色形状，$D$、$C$两点不变，$A$点移动到了$A'$，$B$点移动到了$B'$（其y坐标没有变化）。从图中我们明显能看到y值越大，其偏里原来坐标的程度就越强（参考$F$点的偏移量），现在写出$A$与$A'$的坐标关系： $ (A')_x=A_x+A_ycot\alpha $

写成矩阵的形式：

$$ A'=\left[ \begin{matrix} 1&cot\alpha & 0&0\\ 0&1&0&0\\ 0&0&1&0\\ 0&0&0&1 \end{matrix} \right]A $$



!变换的级联


级联，就是将一系列基本变换合在一起达到组合表现的效果，级联需要注意的是前后变换矩阵的顺序。从矩阵的级联中可以看出，点A先旋转$\alpha$角度后再平移a就是点$C$，而先平移再旋转就是点$D$。我们一般将矩阵写在左边（点$A$的左边），形如$A'=TA$，就是说点A进行T变化。变化后如果需要后续变化的话，继续写在左边（最左边），形如$A'=RTA$，意思就是，先进行T变化，再进行$R$变化。因为矩阵乘法满足结合律，所以我们可以先计算出$RT$相乘的结果$M$，然后再应用到$A$点，就像这样$A'=(RT)A$，别小看这么一个简单的优化，渲染管线中一个批次要处理少则几千几万，多则几十万甚至上百万的顶点，倘若每个顶点都先乘$T$再乘$R$，肯定比只乘$M$理论上慢一倍。而将矩阵$R$，$T$相乘试图在以后减少对顶点的变化次数，这个思想就是级联。


!绕任意顶点的旋转

[{{ :computer-graphics:interactive-computer-graphics:cg3:image_cg3_rotate_1.jpg?200&direct|图中红X是旋转中心，先将旋转中心移回标架原点，就是将$\Delta BCD$平移$(-2,-3)$的距离，平移后为$\Delta B'C'D'$}}]

初学矩阵变化的童鞋可能会犯这样的错误，就是将旋转矩阵的旋转当成了物体绕自己的旋转，这个一定要注意。但实际问题会涉及到大量的物体自旋的情况，比如旋转的风车、高速旋转的乒乓球等等。我们处理物体绕定点旋转的思路一般是先将物体的旋转中心平移回标架原点（连同物体），然后旋转，最后再平移回去。图中所示A是旋转中心，$\Delta BCD$是要旋转的物体，先将A平移回原点，图中可见其平移向量是$u=(-2,-3)$，$\Delta B'C'D'$就是原来物体平移$u$后的位置；然后旋转60度，物体旋转依然是围绕其原点的；第三步将旋转后的$\Delta EFG$再反向平移之前移动的向量，使其旋转中心回到原来的位置，这样就完成了物体绕任意点的旋转操作。




[{{ :computer-graphics:interactive-computer-graphics:cg3:image_cg3_rotate_2.jpg?direct&200|$\Delta B'C'D'$正常旋转60度后为$\Delta EFG$}}]




OpenGL中的物体是靠图元来定义的，而图元是由顶点来组成的，所以物体的变换其实质是组成物体的点的变换，因此变换物体就是变换顶点。我们将刚才的系列变化写成矩阵如下：


[{{ :computer-graphics:interactive-computer-graphics:cg3:image_cg3_rotate_3.jpg?direct&200|将旋转后的$\Delta EFG$平移回原来的位置，也就是移动$(2,3)$的距离，移动后为$\Delta E'F'G'$}}]

$$ \begin {align} P' & =T^{-1}RTP \\ & = \left[ \begin{matrix} 1&0&0&2\\ 0&1&0&3\\ 0&0&1&0\\ 0&0&0&1 \end{matrix} \right] \left[ \begin{matrix} cos60&-sin60&0&0\\ sin60&cos60&0&0\\ 0&0&1&0\\ 0&0&0&1 \end{matrix} \right] \left[ \begin{matrix} 1&0&0&-2\\ 0&1&0&-3\\ 0&0&1&0\\ 0&0&0&1 \end{matrix} \right]P\\ & = \left[ \begin{matrix} cos60&-sin60&0&-2cos60 +sin60 +2\\ sin60&cos60&0&-3cos60-2sin60+3\\ 0&0&1&0\\ 0&0&0&1 \end{matrix} \right]P\\ & = \left[ \begin{matrix} 0.5&-0.866&0&3.598\\ 0.866&0.5&0&0.232\\ 0&0&1&0\\ 0&0&0&1 \end{matrix} \right]P \end{align} $$


[{{ :computer-graphics:interactive-computer-graphics:cg3:image_cg3_rotate_4.jpg?direct&200 |$\Delta E'F'G'$就是原三角形$\Delta BCD$围绕$A$点旋转60度后的位置}}]

顶点$P$是要旋转的点，$P'$是旋转后的位置，$T$是平移变换矩阵，$R$是旋转变换矩阵，$T^{-1}$就是$T$的逆矩阵。我们可将图4.1中$B$点坐标$(2.2,0.92)$带入计算，粗算下的结果为$(3.908,2.1)$，与图4.4中$E'$点坐标$(3.9,2.14)$基本一样。跳出计算过程我们发现，整个示例就是围绕平行于$Z$轴的直线在旋转，只不过这条直线通过了$A$点。这与标题所谓的”绕任意点的旋转”不太吻合。的确是这样，书中这一小节的核心就是此前我们提到的思路“先平移到原点，再旋转，最后平移回去”。如果觉得不过瘾，非要绕给定点旋转，那这本身就不是个严密的问题，因为绕空间中一个点的旋转多了去了，可以上下旋转，左右旋转等等等等，所以我们旋转的重点要看下节：饶任意给定直线的旋转。

!绕任意给定直线的旋转


[{{ :computer-graphics:interactive-computer-graphics:cg3:image_cg3_rotate_line_0.jpg?direct&200|来自《交互式计算机图形学》E文本}}]
[{{ :computer-graphics:interactive-computer-graphics:cg3:image_cg3_rotate_line_1.jpg?200&direct|来自《交互式计算机图形学》E文本}}]

这个问题比起上一节明显具体多了，我们不去计较物体到底是围绕着给定的直线旋转还是物体围绕着以给定直线的方向为轴自己的重心旋转，这都不重要，这节的重点就是我给你一个方向，并且指定一个物体，要你沿着这个方向旋转这个物体。我们此前的讨论都是围绕物体如何绕标架的某一个具体的基的分向量旋转，说到这里可能会有灵感爆发：绕任意直线的旋转可以分成两步，第一步想办法通过一个矩阵$N$将给定直线旋转到与某一条基的分量平行的状态；第二步就是之前的旋转$M$。计算出来后，将他们级联（注意顺序），就是最后的变换矩阵了。看完交计图第三章，第四章多遍后，结合网络上的其他文章，就会发现Edward有意将级联思想灌输给读者：任何复杂的变换，我们都可以用许多基本的变化通过级联的方式得到最终的变换矩阵。这个思想我觉得很重要，一来方便硬件流水线化计算，二来很清晰的展现了矩阵变化的思想，三来有助于理解复杂变换。我们先将“直线”抽象为“单位向量”，并且将空间中这条向量平移到起始点与标架原点重合的位置。紧接着将向量旋转到$xoz$平面。除了将直线围绕$z$轴以外，围绕$x$轴也可以，不过大家都采用$x$轴。我们知道旋转的矩阵是这个样子：

$$ M=\left[ \begin{matrix} cos\theta&-sin\theta\\ sin\theta&cos\theta\\ \end{matrix} \right] $$

其中$\theta$就是要旋转的角度。从矩阵完全可以知道，我们不需要明确的计算出来$\theta$是多少度，只需要知道$cos\theta$与$sin\theta$即可。我们只需要将向量$l$旋转$\theta_x$角度后，就能到$xoz$平面。而$\theta_x$就是向量$d$与$z$轴之间的夹角，而$d$是$l$在$yoz$平面的投影。这样一来$cos\theta_x$与$sin\theta_x$都能算出来，分别是：$cos\theta_x = {\alpha_z \over \|d\|},sin\theta_x = {\alpha_y \over \|d\|}$

写成矩阵形式：

$$ M=\left[ \begin{matrix} 1&0&0&0\\ 0&{\alpha_z \over \|d\|}&-{\alpha_y \over \|d\|}&0\\ 0&{\alpha_y \over \|d\|}&{\alpha_y \over \|d\|}&0\\ 0&0&0&1\\ \end{matrix} \right] $$


就是将$l$旋转到$xoz$平面后的图像，我当年这里有个小小的理解错误，就是将图中淡绿色向量（就是$l$）理解成了图中$l$在$xoz$平面的投影，大家注意，图中的$l$不是原来的投影，而是向量$l$旋转$\theta_x$后的位置。现在就是将图中向量$l$再次旋转到与$z$轴重合，很明显通过围绕$y$轴就可以做到，图中所示旋转$\theta_y$度便是，明显能够知道：$cos\theta_y = {\|d\| \over \|l\|} = \|d\|,sin\theta_y = {\alpha_x \over \|l\|} = \alpha_x$

$$ M=\left[ \begin{matrix} \|d\|&0&-\alpha_x&0\\ 0&1&0&0\\ \alpha_x&0&\|d\|&0\\ 0&0&0&1\\ \end{matrix} \right] $$

看完这个矩阵，如果不假思索，可能会觉得两处$\alpha_x$的符号应该互换。但实际情况是不互换，不要被图中的$\theta_y$角度所欺骗，它只是标注了需要旋转的角度，实际情况是向量$l$旋转了$-\theta_y$度。最后再沿着$z$轴旋转，这之前我们讨论过。

!uniform变量


第三章后面捎带说了下shader中的uniform变量，它是用来修饰变量的，从单词意思就初步能了解该变量在一帧渲染的过程中是不变的。


```
uniform float utime;
attribute vec4 vPosition;
void main(){
  vPosition.x=(1+sin(utime));	
  gl_Position=vPosition;
}

//shader中uniform变量的值是这么与应用程序关联的：

GLint timeParam;
timeParam = glGetUniformLocation("utime");
glUniform1f(timeParam,100.0);
```

!总结


本章前面几节说了下简单的线性代数，比如向量加法、减法、内积、外积、凸性、直线、平面什么的，非常基础。核心内容是变换，我觉得主要抓住对不同仿射空间变换的理解为主，这将为第四章铺好道路，章节最后出现了四元数，这小部分内容对于交计图的基础部分（一到七章）没有用，应该到更后面的层级建模、过程建模里面讲到骨骼的时候可能会更多的用到。



