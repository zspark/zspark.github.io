created: 20190918054012524
creator: Jerry
modified: 20190918140627852
modifier: Jerry
tags: [[OpenGL API]]
title: glBufferStorage glNamedBufferStorage
type: text/vnd.tiddlywiki

glBufferStorage, glNamedBufferStorage — creates and initializes a buffer object's immutable data store

```cpp
void glBufferStorage(GLenum target,GLsizeiptr size,const GLvoid * data,GLbitfield flags);
void glNamedBufferStorage(GLuint buffer,GLsizeiptr size,const void *data,GLbitfield flags);
```

!!Parameters

;target
:Specifies the target to which the buffer object is bound for glBufferStorage, which must be one of the buffer binding targets in the following table: 

{{opengl buffer binding point}}

;buffer
:Specifies the name of the buffer object for glNamedBufferStorage function.

;size
:Specifies the size in bytes of the buffer object's new data store.

;data
:Specifies a pointer to data that will be copied into the data store for initialization, or ''NULL'' if no data is to be copied.

;flags
:Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the following flags. GL_DYNAMIC_STORAGE_BIT, GL_MAP_READ_BIT GL_MAP_WRITE_BIT, GL_MAP_PERSISTENT_BIT, GL_MAP_COHERENT_BIT, and GL_CLIENT_STORAGE_BIT.


!!glBufferData vs glBufferStorage
<<<
Just so you know, this is the same principle behind glTexStorage* (...). Effectively, you sign a contract with the API that says you will never be allowed to change certain properties of your object and in exchange this gives the object immutable status and allows you to do things you normally could not with it.

Texture Views are an interesting example, where the internal image data of an immutable texture can be shared between multiple texture objects and even have its format/dimensions reinterpreted (e.g. 1 slice of a 2D array texture can be shared and used as if it were an ordinary 2D texture).

For vertex buffers, immutable storage opens a class of performance optimizations (e.g. persistent mapped memory) that would not be possible if you could change the size of the buffer at any time. You create a buffer whose size can never be changed, but you are still free to send it new data at any time using glBufferSubData* (...) commands or by writing to the buffer while it is memory mapped.

With glBufferData (...), you can call that command multiple times on the same object and it will orphan the old memory and allocate new storage. With glBufferStorage (...), the buffer's size is set for the lifetime of the object (immutable) and it is an error (GL_INVALID_OPERATION) to call glBufferStorage (...) again once it has been allocated immutably.

In short, it is the data store (storage characteristics) that is immutable, not the actual data.
<<< from: https://stackoverflow.com/questions/27810542/what-is-the-difference-between-glbufferstorage-and-glbufferdata


!!Version Support

|Function / Feature Name| OpenGL Version |<|<|<|<|<|<|<|<|<|<|<|
|~|2.0|2.1|3.0|3.1|3.2|3.3|4.0|4.1|4.2|4.3|4.4|4.5|
|glBufferStorage| - | - | - | - | - | - | - | - | - | - | ✔ |✔|
|glNamedBufferStorage| - | - | - | - | - | - | - | - | - | - | - |✔|