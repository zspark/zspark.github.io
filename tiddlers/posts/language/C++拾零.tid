created: 20191119084611791
creator: Jerry
modified: 20200111082936656
modifier: Jerry
tags: language C++
title: C++拾零
type: text/vnd.tiddlywiki


直接使用map[index]获取到的元素，不能在const函数中，它应该不是const类型，可以使用at函数，举例：

```cpp
std::map m;
const int GetSize(int offset)const{
  return m[offset]->GetSize();
};
```

the correct way is :

```cpp
std::map m;
const int GetSize(int offset)const{
  return m.at(offset)->GetSize();
};
```



!! 2019-12-15
自定义命名空间下不要include标准库，否则会出现好多未定义。

!! chrono

```cpp
std::chrono::milliseconds ms{3}; // 3 milliseconds
// 6000 microseconds constructed from 3 milliseconds
std::chrono::microseconds us = 2*ms;
// 30Hz clock using fractional ticks
std::chrono::duration<double, std::ratio<1, 30>> hz30(3.5);
 
std::cout <<  "3 ms duration has " << ms.count() << " ticks\n"
          <<  "6000 us duration has " << us.count() << " ticks\n"
          <<  "3.5 30Hz duration has " << hz30.count() << " ticks\n";       
```

!!atomic
```cpp
// constructing atomics
#include <iostream>       // std::cout
#include <atomic>         // std::atomic, std::atomic_flag, ATOMIC_FLAG_INIT
#include <thread>         // std::thread, std::this_thread::yield
#include <vector>         // std::vector

std::atomic<bool> ready (false);
std::atomic_flag winner = ATOMIC_FLAG_INIT;

void count1m (int id) {
  while (!ready) { std::this_thread::yield(); }      // wait for the ready signal
  for (volatile int i=0; i<1000000; ++i) {}          // go!, count to 1 million
  if (!winner.test_and_set()) { std::cout << "thread #" << id << " won!\n"; }
};

int main ()
{
  std::vector<std::thread> threads;
  std::cout << "spawning 10 threads that count to 1 million...\n";
  for (int i=1; i<=10; ++i) threads.push_back(std::thread(count1m,i));
  ready = true;
  for (auto& th : threads) th.join();

  return 0;
}
```



!! RAII

这个虽然是老生常谈的事情，但实际应用起来确实很有味道，仅仅了解会使用还不够，要灵活运用。

```cpp
class Resource {
  public:
    explicit Resource(int bytes){
      glGetIntegerv(GL_UNPACK_ALIGNMENT, &m_lastAlignedBytes);
      glPixelStorei(GL_UNPACK_ALIGNMENT, bytes);
    }
    ~Resource(){
      glPixelStorei(GL_UNPACK_ALIGNMENT, m_lastAlignedBytes);
    }

  private:
    int m_lastAlignedBytes;
};
```
局部空间构造一个Resource临时实例，空间出来后实例销毁，还原gl状态，多么的优美。

!! 模板
模板函数，里面要用到具体的函数，但是我希望在一个逻辑里面能简单的使用一个方法得到，可以使用下面这样的写法：

```cpp
// Example program
#include <iostream>

class Json{
    public:
    int GetInt(){
        return 1;
    };
    float GetFloat(){
        return 2.0f;
    };
    bool GetBool(){
        return true;
    };
    double GetDouble(){
        return 3.0;
    };
};

template <typename T>
void GetValue(Json& j,T&);

template<>
void GetValue(Json& j,int& a){
    a= j.GetInt();
}
template<>
void GetValue(Json& j,float& a){
    a= j.GetFloat();
}
template<>
void GetValue(Json& j,bool& a){
    a= j.GetBool();
}
template<>
void GetValue(Json& j,double& a){
    a= j.GetDouble();
}

int main()
{ 
  Json j;
  int i=-1;  GetValue(j,i);
  float f=-1.0f;  GetValue(j,f);
  bool b=false;  GetValue(j,b);
  double d=-1.0;  GetValue(j,d);
  std::cout<<"Print:"<<i<<","<<f<<","<<b<<","<<d<<std::endl; //Print:1,2,1,3
}
```



!!lock_guard
互斥类的最重要成员函数是lock()和unlock()。在进入临界区时，执行lock()加锁操作，如果这时已经被其它线程锁住，则当前线程在此排队等待。退出临界区时，执行unlock()解锁操作。更好的办法是采用”资源分配时初始化”(RAII)方法来加锁、解锁，这避免了在临界区中因为抛出异常或return等操作导致没有解锁就退出的问题。极大地简化了程序员编写mutex相关的异常处理代码。C++11的标准库中提供了std::lock_guard类模板做mutex的RAII。

std::lock_guard类的构造函数禁用拷贝构造，且禁用移动构造。std::lock_guard类除了构造函数和析构函数外没有其它成员函数。

在std::lock_guard对象构造时，传入的mutex对象(即它所管理的mutex对象)会被当前线程锁住。在lock_guard对象被析构时，它所管理的mutex对象会自动解锁，不需要程序员手动调用lock和unlock对mutex进行上锁和解锁操作。lock_guard对象并不负责管理mutex对象的生命周期，lock_guard对象只是简化了mutex对象的上锁和解锁操作，方便线程对互斥量上锁，即在某个lock_guard对象的生命周期内，它所管理的锁对象会一直保持上锁状态；而lock_guard的生命周期结束之后，它所管理的锁对象会被解锁。程序员可以非常方便地使用lock_guard，而不用担心异常安全问题。


!! 最大／最小宏，有意思


```cpp
//Solution
#define GENERIC_MAX(x, y) ((x) > (y) ? (x) : (y))

#define ENSURE_int(i)   _Generic((i), int:   (i))
#define ENSURE_float(f) _Generic((f), float: (f))


#define MAX(type, x, y) \
  (type)GENERIC_MAX(ENSURE_##type(x), ENSURE_##type(y))

//Usage
MAX(int, 2, 3)
```
