created: 20190818081615817
creator: Jerry
modified: 20190818150526064
modifier: Jerry
tags: algorithm 
title: GJK算法原理简述
type: text/vnd.tiddlywiki

//The Gilbert–Johnson–Keerthi Algorithm简称GJK算法，是由Gilbert、Johnson、Keerthi三人共同开发的一类迭代算法。GJK算法并不对参数本身做改变，而是利用参数计算明科夫斯基差，将两个点集的距离计算转化为一个点集与原点的计算问题，其迭代过程是不断判断逻辑上是否存在更有可能会包含原点的明科夫斯基子空间。下面只是针对二维空间进行相关GJK说明。 //

! 算法的理论基础

      我们计算平面中两个点A,B距离的时候，最常见的方法就是用A减去B，然后再计算这个全新向量C的模，当我们进一步思考的时候就会发现新向量C的模其实是向量C与原点O的距离。如此一来的话，我们可以简单的推导出这样一个事实：要计算平面中A,B两点的距离，可以尝试找到另一个点C，然后计算C与原点O的距离，也就是直接计算点C的模。这种思想的重点并不是如何去计算点C，而是两个变量之间的一些外部关系（比如A,B之间的距离，没有A便不存在A,B距离这一概念）可以变换到一个变量的内部关系（只计算C的模），这是一个质的变化。现在我们扩展到点集中，假设有两个点集SetA(n)与SetB(m)，由于其差集中的任何一个点必然是从SetA与SetB中计算而来，那么当差集中有一个点与原点重合的话，就意味着SetA与SetB中至少存在一对点Pa与Pb，它两的距离为0（重合在一起）。这就是GJK算法的理论基础，它的核心思想就是尝试计算差集中的点与原点的位置关系，从而确定点集SetA、SetB之间的位置关系；计算几何中一个基本术语明科夫斯基差(Minkowsky minus)就与其相关；

! 术语

*边缘点    科夫斯基差空间下形成凸包?的点； 
*差形    SetA中的点减去SetB中的点，所构成的明科夫斯基空间。 
*差集    成差形的点集； 

! 明科夫斯基和

      先说说明科夫斯基和(Minkowsky plus)，其本质就是两个变量的加法运算，变量可以是但不限于一维、二维、三维向量，其和就是向量的分量和，结果自然也是个同纬度的向量；明科夫斯基和在几何上的直观表现就是SetA的凸包以SetB的凸包形状移动之后的扫略图形。当然会有一些修正，但这不是重点，也易于理解，明科夫斯基差可以看作是SetA与−SetB和。
支持函数

      我们现在知道两个点集SetA(n)，与SetB(m)；倘若用SetA中的每一个点去与SetB中的每一个点计算明科夫斯基差，会是一种什么情况？就会产生n∗m个空间点，而这些点必然有许多不是差形的边缘点，这就意味着去计算这些点的明科夫斯基差是一种浪费性能与时间的操作，我们肯定要尝试去减少这样的计算，最好没有冗余的计算，于是支持函数(support function)就这样出现了。

      我们试图使用支持函数去找到理论上一定是边缘点的点，最好是其顶点。怎么做到呢？我们知道，凡是差集中的点都是一个点集中的点去减去另一个点集中的点，倘若SetA整体在右边，SetB整体在左边，那么我用SetA中最右边（x值最大）的点减去SetB中最左边（x值最小）的点（假如是点p)，势必p.x是所有可能组合中x值最大的，那么点p肯定就是个边缘点。同理，当我们用SetA中最右边的点减去SetB中最右边的点，形成的点肯定也是个边缘点。y方向也是一样，当然我们可以用任意方向。它们的共性是：都是给定一个具体的方向，得出这个方向上SetA中的最远的点（或者最近的点），然后得到SetB中最近的点（或者最远的点），做明科夫斯基差计算后，结果点肯定是个边缘点。
支持函数的具体逻辑


```cpluscplus
private function supportFn(SetA:Array,SetB:Array,dir:Vector2D):Vector2D{
  var mostFarInSetA:Vector2D=getFarthestPoint(SetA,dir);
  var mostNearInSetB:Vector2D=getFarthestPoint(SetB,-dir);

  var mkwPoint:Vector2D=mostFarInSetA-mostNearInSetB;
  return mkwPoint;
}
```


! 单纯形

      有了支持函数后便更近了一步，因为从此之后我们得到的任何一个点都会是在差形的边缘（或者是其顶点），接下来就是判断差形与原点的位置关系了。如下图FIXME，我们计算出了差形中的一个点M，但我们难以仅以M与原点O有位置关系判断出整个差形与原点的位置关系，所以需要我们再得到更多的边缘点。一般的做法就是简单的反转得到点M的方向，然后计算另一个点，这样做是有一定原因的，其一：反转一个向量的方向要比全新创建一个向量速度快；其二：从目前仅有的点M我们无法知道整个差形的形状（甚至是大概形状），如下图，差形可能与原点有好多关系。所以在这样信息不全的情况下，我们没有必要大费周折去计算一个自认为更优秀的方向。有了点N要想形成一个平面形状，至少要有三个点，组成一个单纯形，然后判断原点是否在其中，在的话表明SetA与SetB相交。
向量三重积

      一般学习线性代数都会遇到三重积，但那个是标量三重积，意思就是先计算两个向量的叉积，其结果再与最后一个向量做点积，最后的结果是个标量，可理解为空间菱状体的体积；而向量三重积意思是三个向量全部使用叉积计算，其最终结果依然是个向量；当我们找到两个差形边缘点后，第三个点的查找便有了一定的依据，因为我们的目的就是判断原点是否在差形里面，所以第三个点的查找肯定是向着原点的方向，否则便是徒劳。如图下图所示，红色箭头就是希望寻找的方向，它与A，B两点垂直，要计算该方向需要用到向量三重积，新的方向下会计算出来一个新边缘点，这样就形成了一个三角形，现在问题是如何判断这个单纯形（三角形）包含原点呢？

! Voronoi域

      Voronoi域(或者叫诺图、泰森多边形)是计算几何分支的一个重要概念，这里仅说二位空间下的Voronoi域。当我们将一个平面凸形的每条边延长后会发现整个二维空间被分割成几个区域如图所示，这些区域中有的占有原来图形的一条边，有的仅占有一个点，有的却占有整个面，除此之外别无其他，这三种不同的区域就是三种Voronoi特征域，依次被称作边域、点域、面域。当我们计算出单纯形中的三个点后，能肯定的是其他边缘点肯定不会在点域，因为如果存在的话，该点域所在的唯一点便是单纯形中的一个内部点，这根使用支持函数计算边缘点相矛盾，故此倘若再有其他边缘点肯定不会落于当前单纯形的顶点域中，这样一来我们的判断就可以分割成判断原点是否落于面域之内。判断点落于那个Voronoi域最简单的做法就是判断点与组成图形边的位置关系，问题便简化为点与线段的计算，更进一步便是点积的正负问题。

! 迭代计算

      当我们判断出原点位于某个点域内，便能一口得出SetA与SetB不相交；而位于面域内便是一定相交。边域的话就需要进一步计算，此时就要判断应该丢掉第一个得出的边缘点还是第二个（第三个是在第一、二个边缘点的存在下得出的，故此它比前两个更具有有效性，试想如果丢掉第三个点，再次计算不还是得到第三个点嘛）。判断的依据依然是原点落在了哪个Voronoi边域内，如图，落在A域的话，自然丢掉A点；丢掉后便是第一次递归计算了，与之前一样找出点三个点，然后全新的判断一次Voronoi域域原点的位置关系，直到肯定的退出或者逻辑有个迭代上限而退出。

http://www.codezealot.org/archives/153#gjk-convexhull 
