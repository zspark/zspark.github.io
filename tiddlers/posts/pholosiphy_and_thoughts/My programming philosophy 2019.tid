created: 20191203050258228
creator: Jerry
modified: 20191208093752050
modifier: Jerry
tags: [[Philosophy and thoughts]]
title: My programming philosophy 2019
type: text/vnd.tiddlywiki

[img [https://raw.githubusercontent.com/zspark/assets/blog/code.jpg]]

!! 直接逻辑
网上查了查，没有''直接逻辑''这个术语（或者至少不是大众随便可知的），我便拿来用于我的编程哲学。
我们在写程序的时候，少不了判断，如果设计不精良导致判断重复、多余，那应该不是什么令人一定开心的事情，如何减少重复的逻辑判断，这也确实是门学问。举个例子：

```cpp
bool Resize(void* handler,int w,int h){
  someConcreteType* h=(someConcreteType*)handler;
  if(!h){
    return false;
   }else{
    // some logic with h;
    return true;
  }
}

void* CreateNewOne(void* oldHandler,int w,int h){
  someConcreteType* h=(someConcreteType*)oldHandler;
  if(h){
    Destroy(oldHandler);
  }
  h=new someConcreteType();
  Resize((void*)h,w,h);
  return (void*)h;
}
```

上述代码中，很显然CreateNewOne()中新创建的someConcreteType实例是存在的，但是在调用Resize()函数后，其内部又判断了一遍，这是多余的逻辑判断，如何避免？首先需要肯定的是：这种写法没有问题，顶多一个判断而已，如果其他地方有调用Resize()函数，判断岂不是就派上用场了吗。

我这里所表述的''直接逻辑''并非否认上述写法，而是思考能否在一定约束下实现一些''直接了当对面函数名表达的逻辑''的函数，比如将Resize()函数写成：

```cpp
void Resize(void* handler,int w,int h){
  someConcreteType* h=(someConcreteType*)handler;
  // some logic with h;
}
```
短小而精悍，没有逻辑判断（因为函数的名字就是“重置大小”，并没有说''CheckAndResize''），这样的函数我称其为''直接逻辑''函数。判断逻辑就留给高层应用，不过函数在逻辑复杂的时候不要使用直接逻辑，而在频繁执行的逻辑内，我觉得还是''直接逻辑''好些。

!!明确分层
如果有这样一个结构的拓扑关系：user->[C->B]，我们把他们想象成库，BC全是静态库，各自都有头文件提供给上一层使用（不能跨层使用），库Ｃ提供的头文件仅仅为user服务，如果我们在C的头文件中有这样一个API函数：

```cpp
void* CreateCamera(ECameraType type);
```

而枚举值ECameraType却定义在Ｂ提供的头文件中，此时我们可以包含B中的某一文件到C的头文件中，以便user可以正确使用接口，但我们违背了设计的要求：''下一层仅仅为上一层（并非其上的各层）提供服务。''

我们具体一下BC：假如B为渲染器，C为引擎，那么诸如ECameraType就压根不会出现在B中，而是在C中。如果我们有类似上面的情况，我觉得很大可能是架构设计的不漂亮，其并没有明确“层”的抽象度与边界，越是低层（被引用的越多的）库，其抽象程度势必很高，其中的概念势必尽可能的为其提供的功能而服务，无论怎样的相机，他们在渲染层无非一个矩阵而已。


 ¶ 
