created: 20190828113219195
creator: Jerry
modified: 20190919061206488
modifier: Jerry
tags: excerpted _mcintro_ [[computer graphics]] Math
title: 1. 蒙特卡洛方法的快速介绍
type: text/vnd.tiddlywiki


{{_mcintro_}}














本章译者：Jerry




{{ :math:mc-series:roulette.png?nolink&600 |}}

! 蒙特卡洛方法的快速介绍 

[{{ :math:mc-series:jellybeans01.png?nolink|Jelly beans}}]

什么是MC？MC方法背后的概念既简单又健壮。然而，就像我们马上要看到的那样，它需要大量潜在的计算，这就是它为什么能随着计算技术的发展而闻名。生活中很事情除非用大量的数据否则无法精确计算。比如，虽然不是不可能，去统计一下1kg坛子中的果冻豆数量需要很长的时间。你可能会用手一个一个的数，这需要大量的时间（好像你从来没有过比这更好的工作一样）。计算一下某个国家成年人口的平均身高，需要测量下这些人口的个体身高，加起来然后除以统计的人口数，这依然是个需要大量时间的工作。我们能代替的一个方案是采集这些人口中的一些个样本，然后计算平均身高。不幸的是这样做并不会准确的给你全部人口的平均身高，然而这个技术给了一个大体上**逼近**准确值的结果。我们用准确性换取了效率。我们熟知的民意调查就是基于这个原理。说来也怪，逼近的结果有时与准确的人均完全身高一样。这仅仅取决于几率。大多数情况下这个数字不一样。有一个问题我们可能会问，会有多少不一样？实际上，随着采样数量的增加，这个逼近收敛于准确的数字。换句话说，逼近值与准确值之间的误差会随着采样数量的增加而减小。直观上说，这个想法容易理解，然而我们会在下章（从数学的角度）看到一个不同的解释与整合。注意为了公平起见，采样的元素需要相同的概率被选中。

注意一个人的高度是一个随机数。它可以是任何数，这是随机事物的本质。因此，当你用随机选取一些人口，然后测量他们的身高以逼近平均值的方法去采集人口身高，每个测量都是个随机的数字（因为每个你测量的人都有可能具有不同的高度）。有趣的是，随机数的和是另一个随机数。 如果你不能预测要加的数学是什么，又如何能预测加完之后的和是什么？所以，和的结果是个随机数，要加的数字也是个随机数。


























在数学家眼里，人口的高度会被叫作''随机变量''，因为记录着人口的高度随机的变化。我们通常将随机变量用大写字母表示。通常使用字母$$X$$。

在统计学中，记录了人口信息的元素--如前所述是个随机数--用小写字母表示，通常使用$$x$$。比如，如果我们写个$$x_2$$，意思是统计人口中第二个人的身高（是个随机数）。所有的$$x$$也可以看作是随机变量$$X$$的所有可能结果。如果我们称随机变量$$X$$为人口身高，我们可以用下面的伪数学公式来表达来自成年人口采样的平均高度的逼近这一概念：

$$
Approximation(Average(X))={\frac1N}\sum_{n=1}^Nx_n
$$

上面公式读作：随机变量$$X$$（某国家成年人口的高度）的均值逼近，等于随机选取的$$N$$个成年人口高度（采样值）的和，除以数字$$N$$（样本大小）。这个本质上就是我们称作的''蒙特卡洛逼近''。它够成了一组非常大的对象的一些属性的逼近，只需要平均这$$N$$个随机选取的属性即可。你也可以说MC逼近事实上是利用样本做逼近的方法。下章我们将知道想要被逼近的事物叫做数学期望（更多内容马上呈现）。此前提到过给定国家成年人口的高度被看作是个随机变量$$X$$。然而需要注意的是他们的均值是个唯一值。（为了避免与样本数量$$N$$混淆，我们将使用$$M$$表示所有人口的数量）：

$$
Average(X)={\frac1M}(x_1+x_2+...+x_M)
$$

上面$$x_1,x_2,x_M$$代表所有人口中每一个人的高度，就像此前说的那样（如果你想举例的话）。在统计学中，随机变量$$X$$的平均值叫作''期望''，写作$$E(X)$$。

<<<
总结一下，MC逼近（MC方法的一种），是个使用样本逼近随机变量期望值的技术，它如下定义：

$$E(X)\approx{\frac1N}\sum_{n=1}^Nx_n$$

数学符号$$\approx$$意思是在它右边的仅仅是随机变量$$X$$的期望$$E(X)$$真实值的“逼近”。注意从另一方面来说它就是随机数 $$x_nS$$的平均值而已.
<<<

如果你仅仅对隐藏在神秘术语MC被后的东西感兴趣，那么所有你需要知道的就是上面的总结。为了完成这次快速介绍，我们再解释下为什么这个方法很有用。此前提到计算$$E(X)$$有时很难。这意味着至少你不能快速计算精确的$$E(X)$$。这在特别情况下是对的比如特大“人口”去计算$$E(X)$$。MC逼近提供一种简单快速的途径逼近期望。它不能给你准确的值，但它肯定能以精确计算$$E(X)$$的一小部分代价得到足够靠近它的结果，if or possible at all.




! MC，有偏与无偏射线追踪 

为了达成这篇快速介绍，我们意识到你们中有些人已经听过术语''MC射线追踪''，及其术语''有偏射线追踪''和''无偏射线追踪''，或许是从这里第一次看到，希望能从这里得到这些术语的解释。让我们快速开始，即使我们确实建议你阅读这个系类剩下与这章剩下的的内容，以便更深入的得到问题的答案。

[{{ :math:mc-series:areacam1.png?direct&300|图 1：图像上的每个像素其实是个小表面。通过它看到的物体表面的颜色在像素面积区域内变化。}}]

想像你想要使用数码相机拍照。如果你划分图像表面成常规的格子（我们的像素），注意到每一个像素可以看作是看起来小但连续的连续的表面，这些表面接收来自场景中物体反射的光线。这些光将最终被转化成单一的颜色（我们一会将讨论处理过程），然而当你通过这些像素观察的时候，你可能会注意到它实际上能看到更多的对象，或者对象表面上的不同颜色，它们都在像素区域变化。我们在图1中展示了这个观点。我们想要做的，理想情况下就是去计算从表面反射的通过像素区域的所有光线的总和。这典型的是个完不成的问题，没有方法能够实际上对通过整个像素表面的光线积分。然而我们可以从数学的角度写出这样的想法，实际上这个等式是没有解决方案的：

$$
L_{pixel}=\int_{pixelarea}L(x_p)dA
$$

等式中L表示radiance（译注：这里是原文关于radiance的文章链接）。等式可以这样读“到达一个像素的真实能量总和可以通过计算到达像素表面区域的radiance的积分得到”，就像我们刚说的，这个问题没有解析解，需要数值逼近方案代替。

[{{ :math:mc-series:areacam2.png?direct&300|图 2：像素的radiance逼近值可以通过平均随机选取的像素区域内的采样点（黑点）得到。样本的颜色通过射线追踪获得。}}]

再次说下这里的原理非常简单，它通过采样像素表面不同区域的方法构成这个积分结果的逼近。换句话说，因为要使用MC逼近，我们将采取“随机采样”去预估这个积分（并得到其结果的逼近）。所有需要做的就是随机采集像素区域中的一些个样本，然后计算颜色均值。现在的问题是我们如何找到这些样本的颜色？当然是使用射线追踪了！射线通常起始于眼睛处，然后射向像素区域随机采样点的位置（图2）。射线与场景中对象相交位置处的颜色就是样本的颜色。数学上我们这样写：

$$
L_{pixel}\approx{\frac1N}\sum_{n=1}^NL(x_n)
$$

上式中$L(x_n)$表示采样的颜色。通常，这仅仅是个逼近值（因此使用$\approx$符号）。这个方法叫作MC积分（即使与MC逼近方法相近，这里用它来计算积分的逼近）。读者如果对MC积分的正式定义感兴趣的话可以查阅下一讲。这里仅仅是对概念的非正式且快速的介绍。

如果你对问题还没有很好的理解，让我们想像从一个像素看出去能看到16见方的格子，每个格子一种颜色（见图3）。问题显然变的简单了，因为我们实际上仅仅只有256种可以区分的颜色。计算像素的颜色在这种情况下变的可行：我们只需要将这些颜色加起来，然后除以256.但是如果格子变的无限大，这个解决方案就行不通。如果我们想要得到这个问题的逼近，所有要做的事情就是采集比如说8个不同位置（8仅仅是举个例子，它表示样本大小$N$，它的值如果你愿意可以是任何数），获取格子中这些位置的颜色，加起来然后除以8.见图3

[{{ :math:mc-series:mcintegration01.png?direct&300|图 3：使用MC逼近计算表面的颜色（示例中采取8个样本）}}]

[{{ :math:mc-series:mcintegration04.png?direct&300|图 i：（原文没有图i，我这里是为了排版。）}}]

从图3中可以看出，逼近值与均值比较接近，但仍然能看出不同。这上MC方法的缺陷，它仅仅给我们逼近值，另一个缺陷是每次计算的全新的逼近值是不同的。这是源自该方法的随机本质（每次全新逼近计算时，8个样本会变化）。下图就是16次（每次8个样本）全新的逼近结果。

{{:math:mc-series:mcintegration02.png?nolink|}}

一个好的消息是，你可以通过增加样本数量来减少误差。坏消息是，你想将误差减小2倍，需要2倍的样本数量。这就是MC方法为什么会有慢的坏名声。对此一个更加准确的描述是它的收敛性（随着样本数量的增加，它有多快能会聚成准确的结果）相当低。这个会在下面的内容及其本课程学到。下图依次展示了8，16，32，64，128，256个样本下的16次逼近结果。

{{:math:mc-series:mcintegration03.png?nolink|}}


正如我们期望的那样，随着样本数量的增加，逼近值之间的不同也在减小。在你的渲染器（假设你使用的是射线追踪）中这个渲染结果的不同被称作**噪点**。它是由实际结果与你的逼近结果之间的不同造成的。技术上说正确的名字叫做**方差**（概率论与数理统计对于学习方差非常有用）。你通常会因采样过少而得到较多的噪点，或者相反的说增加样本数量会减少噪点（或者说是方差）。然而需要注意的是通过逼近方式得到的方差（假设他们样本者是一样的）也会依赖于原始格子中颜色之间的方差。在图i的示例中，我们看到格子中的颜色与亮度变化要比上一个示例复杂。而上一个示例中256个样本的逼近几乎看不出来，但这里相比它更加明显。


它是什么时候发生的？当你从一个像素看向外面的时候，会发现许多物体或者少数几个或者一个物体表面的复杂性。通常而言，你想要避免这种从一个像素能够看到非常大的场景的情况，因为越是细节多，越需要更多的采样来较少噪点。这个想法通常与''失真''、''重要性采样''这些概念关联。这里是我们用来生成结果的代码：

```cpp
#include <fstream> 
#include <cstdlib> 
#include <cstdio> 

int main(int argc,char **argv){
  std::ifstream ifs;
  ifs.open("./tex.pbm");
  std::string header;
  uint32_t w,h,l;
  ifs>>header;
  ifs>>w>>h>>l;
  ifs.ignore();
  unsigned char *pixels=new unsigned char[w * h*3];
  ifs.read((char*)pixels,w * h*3);
  // sample
  int nsamples=8;
  srand48(13);
  float avgr=0,avgg=0,avgb=0;
  float sumr=0,sumg=0,sumb=0;
  for(int n=0; n<nsamples; ++n){
    float x=drand48() * w;
    float y=drand48() * h;
    int i=((int)(y)* w+(int)(x))*3;
    sumr+=pixels[i];
    sumg+=pixels[i+1];
    sumb+=pixels[i+2];
  }
  sumr/=nsamples;
  sumg/=nsamples;
  sumb/=nsamples;
  for(int y=0; y<h; ++y){
    for(int x=0; x<w; ++x){
      int i=(y * w+x)*3;
      avgr+=pixels[i];
      avgg+=pixels[i+1];
      avgb+=pixels[i+2];
    }
  }
  avgr/=w * h;
  avgg/=w * h;
  avgb/=w * h;
  printf("Average %0.2f %0.2f %0.2f, Approximation %0.2f %0.2f %0.2f\n",avgr,avgg,avgb,sumr,sumg,sumb);
  delete[] pixels;
  return 0;
}
```

因为我们使用了射线追踪去预估MC积分中的样本，这个方法叫作''MC射线追踪''（也叫作随机射线追踪((原文：it also called Stochastic Ray Tracing - The term stochastic is synonymous of random)) ）。

三篇对后世影响深远的论文介绍了这个方法：

    * The Rendering Equation (Kajiya 1986)
    * Stochastic Sampling in Computer Graphics (Cook 1986)
    * Distributed Ray-Tracing (Robert L. Cook, Thomas Porter, Loren Carpenter 1984)

现在让我们讨论下术语有偏与无偏。在统计学中，我们计算$$E(X)$$的逼近值的方法（规则）叫作`估算器`。方程：

$$
Approximation(E(X))={\frac1N}\sum_{n=1}^Nx_n
$$

就是估算器的示例（实际上，它是个简化了的MC估算器，我们叫它`基础估算器`。你可以从下一讲找到MC估算器的完整方程与定义）。随着样本数量$N$的增加估算器的结果越来越接近期望值的话，我们称这样的估算器为`无偏的`。实际上，我们能够证明随着$N$趋向于无穷，逼近值收敛于真实结果。另一种表达方式是随着$N$取向于无穷，逼近值与期望值之差收敛于0.我们可以这样写：

$$
Approximation(E(X))-E(X)=0 \text { as N approaches }\infty
$$

[{{ :math:mc-series:mcintegration05.png?direct&300|图 4：我们同样可以使用MC积分去逼近计算有多少光到达一个点。}}]

[{{ :math:mc-series:mcintegration06.png?direct&300|图 5：我们使用递归过程计算到达可见点P的光量。}}]

这实际上就是MC估算器。总体来说MC估算器是个无偏估算器。但是随着$$N$$趋向于无穷，估算值与期望值之间的差不趋向于0，那么就说这个估算器是`有偏的`。这并不是说随着$$N$$趋向于无穷，估算器没有收敛于一个固定的值，而是收敛于一个与期望值不同的另一个值。乍一看无偏估算器比有偏估算器好，但是为什么我们需要或者会用到这样一个估算结果与期望有差异的估算器呢？因为它们中的一些估算器具有有趣的属性。比如如果偏差足够小，但是收敛率比无偏估算器要快很多，这就可以看作一个有趣的属性。这些有偏估算器的估算值，在相同样本数量的情况下，其方差可能比无偏估算器的结果也小。换句话说，如果你用有偏估算器计算几次逼近值，你可能会得到更的小方差（相同的样本数量）。这也是潜在的一个有趣的特性。总结来说，你可以既拥有有偏也拥有无偏MC射线追踪器。有偏MC射线追踪器可能会得到较少的噪点或者更快的性能。然而使用有偏估算器相比“真实的”结果你可能会摄入一些误差（偏差）。通常而言这些偏差比较小（否则它们就没有优势可言），如果你不知道的话根本不会注意到它们的存在。


我们可以进一步扩展MC射线追踪。在Shading (译注：Shading是[[这里|http://www.scratchapixel.com]]的另一篇文章) 入门课程中提到，要计算射线与对象表面交点$P$处的颜色，需要对$P$点的上半球所有入射光线做积分（上半球以法线方向为主）。如果你还没有想到的话，下面就是这个积分直白的写法：

$$
L_P=\int_{\Omega}L_\Omega
$$

公式中$$\Omega$$表示半球面。通常，这涉及到对连续区域的积分，该积分没有解析解。于是，这里我们可以再次使用MC积分方法。想法就是通过在其表面上随机的采样，然后从$$P$$点发射射线，穿过采集的点在半球面上采样，以便得到到达$$P$$点的光的多少（见图4）。换句话说就是，我们从可见的$P$点随机的发射射线然后平均它们的结果。

$$
L_P\approx{\frac1N}\sum_{n=1}^NL_n
$$

这就是MC射线追踪典型的工作方式。需要注意的是，当我们从点$P$向场景发射射线想要获得有多少光来自该方向时，这条射线又与场景中其他对象发生相交，我们要使用相同的方式逼近计算有多少光会被新相交的对象返回。整个过程是个递归调用。因为我们跟随着光线的路径，所以这个算法有时被叫作``路径追踪（算法）``。如图5所示。

这个想法也可以通过下面的伪代码表达。

```cpp
Vec3f monteCarloIntegration(P,N){
  Vec3f lightAtP=0;
  int nsamples=8;
  for(int n=0; n<nsamples; ++n){
    Ray sampleRay=sampleRayAboveHemisphere(P,N);
    Vec3f Phit;
    Vec3f Nhit;
    if(traceRay(sampleRay,Phit,Nhit)){
      lightAtP+=monteCarloIntegration(Phit,Nhit);
    }
  }
  lightAtP/=nsamples;

  return lightAtP;
}

void render(){
  Ray r;
  computeCameraRayDir(r,...);
  Vec3f Phit;
  Vec3f Nhit;
  if(traceRay(r,Phit,Nhit)){
    Vec3f lightAtP=monteCarloIntegration(Phit,Nhit);
    ...
  }
}
```

显然，所有这些就是对MC射线追踪的一个快速并且逼近（可以这么说）介绍。为了获得更加准确与完整的信息，我们强烈建议你阅读剩下的课程，还有下面的内容。

总结一下，我们说MC方法是依赖随机采样以逼近结果的数值技术((原文是：numerical techniques relying on random sampling to approximate results))，特别是积分结果。这些积分有时可以使用其它技术解决（如果你感兴趣，可以查查Las Vegas算法的举例），然而，下章我们将向你展示相比其它方案它所具有的更有用的属性（尤其是在计算计图形学中要涉及的积分排序）。

MC绝对是渲染领域的核心。它关联到许多重要的其他主题比如采样，重要性采样，光线传输算法，而且同样使用在其它重要渲染技术里面（尤其是在着色方面）。


! 下一步是什么 

作为最后对于本章的总结，你可以看一看下面有趣的视频，它来自BBC纪录片的一个剪辑。它展示了平均所有的随机数从而达到逼近值的能力。课程剩下的内容将覆盖概率论与数理统计的基础理论。它涵盖了PDF，CDF等重要的概念，还有下章要铺开来说的反推法。

--EOF


